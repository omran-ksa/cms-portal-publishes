const c=[],I="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";for(var l=0,H=I.length;l<H;++l)c[l]=I[l];function M(s){return c[s>>18&63]+c[s>>12&63]+c[s>>6&63]+c[s&63]}function Y(s,e,t){for(var r,n=[],o=e;o<t;o+=3)r=(s[o]<<16&16711680)+(s[o+1]<<8&65280)+(s[o+2]&255),n.push(M(r));return n.join("")}function F(s){for(var e,t=s.length,r=t%3,n=[],o=16383,i=0,a=t-r;i<a;i+=o)n.push(Y(s,i,i+o>a?a:i+o));return r===1?(e=s[t-1],n.push(c[e>>2]+c[e<<4&63]+"==")):r===2&&(e=(s[t-2]<<8)+s[t-1],n.push(c[e>>10]+c[e>>4&63]+c[e<<2&63]+"=")),n.join("")}class u{constructor(e,t){this.message=e,this.extras=t}}const x=typeof window<"u"&&!!window.crypto,G=x&&!!window.crypto.subtle,d="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";function E(s){const e=[];for(let t=0;t<s.byteLength;t+=1){const r=s[t]%d.length;e.push(d[r])}return e.join("")}function S(s){return F(new Uint8Array(s)).replace(/\+/g,"-").replace(/\//g,"_").replace(/=/g,"")}function P(s){const e=new ArrayBuffer(s.length),t=new Uint8Array(e);for(let r=0;r<s.length;r++)t[r]=s.charCodeAt(r);return t}class p{generateRandom(e){const t=new Uint8Array(e);if(x)window.crypto.getRandomValues(t);else for(let r=0;r<e;r+=1)t[r]=Math.random()*d.length|0;return E(t)}deriveChallenge(e){return e.length<43||e.length>128?Promise.reject(new u("Invalid code length.")):G?new Promise((t,r)=>{crypto.subtle.digest("SHA-256",P(e)).then(n=>t(S(new Uint8Array(n))),n=>r(n))}):Promise.reject(new u("window.crypto.subtle is unavailable."))}}const K=!0,Q=!1;function h(s,...e){(e?e.length:0)>0?console.log(s,...e):console.log(s)}function V(s,e,t){return t}const Z=10,W=function(s){return s.generateRandom(Z)},_=class L{constructor(e,t=new p,r=!0){this.crypto=t,this.usePkce=r,this.clientId=e.client_id,this.redirectUri=e.redirect_uri,this.scope=e.scope,this.responseType=e.response_type||L.RESPONSE_TYPE_CODE,this.state=e.state||W(t),this.extras=e.extras,this.internal=e.internal}setupCodeVerifier(){if(this.usePkce){const e=this.crypto.generateRandom(128);return this.crypto.deriveChallenge(e).catch(t=>{h("Unable to generate PKCE challenge. Not using PKCE",t)}).then(t=>{t&&(this.internal=this.internal||{},this.internal.code_verifier=e,this.extras=this.extras||{},this.extras.code_challenge=t,this.extras.code_challenge_method="S256")})}else return Promise.resolve()}toJson(){return this.setupCodeVerifier().then(()=>({response_type:this.responseType,client_id:this.clientId,redirect_uri:this.redirectUri,scope:this.scope,state:this.state,extras:this.extras,internal:this.internal}))}};_.RESPONSE_TYPE_TOKEN="token",_.RESPONSE_TYPE_CODE="code";let A=_;class X{constructor(){this.listener=null}setAuthorizationListener(e){this.listener=e}onAuthorizationComplete(e,t,r){this.listener&&this.listener(e,t,r)}}const v=["redirect_uri","client_id","response_type","state","scope"];class q{constructor(e,t){this.utils=e,this.crypto=t,this.notifier=null}buildRequestUrl(e,t){const r={redirect_uri:t.redirectUri,client_id:t.clientId,response_type:t.responseType,state:t.state,scope:t.scope};if(t.extras)for(const o in t.extras)Object.prototype.hasOwnProperty.call(t.extras,o)&&v.indexOf(o)<0&&(r[o]=t.extras[o]);const n=this.utils.stringify(r);return`${e.authorizationEndpoint}?${n}`}completeAuthorizationRequestIfPossible(){return h("Checking to see if there is an authorization response to be delivered."),this.notifier||h(`Notifier is not present on AuthorizationRequest handler.
          No delivery of result will be possible`),this.completeAuthorizationRequest().then(e=>{e||h("No result is available yet."),e&&this.notifier&&this.notifier.onAuthorizationComplete(e.request,e.response,e.error)})}setAuthorizationNotifier(e){return this.notifier=e,this}}class O{constructor(e){this.code=e.code,this.state=e.state}toJson(){return{code:this.code,state:this.state}}}class U{constructor(e){this.error=e.error,this.errorDescription=e.error_description,this.errorUri=e.error_uri,this.state=e.state}toJson(){return{error:this.error,error_description:this.errorDescription,error_uri:this.errorUri,state:this.state}}}class z{}class g extends z{xhr(e){if(!e.url)return Promise.reject(new u("A URL must be provided."));const t=new URL(e.url),r={};r.method=e.method,r.mode="cors",e.data&&(e.method&&e.method.toUpperCase()==="POST"?r.body=e.data:new URLSearchParams(e.data).forEach((o,i)=>{t.searchParams.append(i,o)})),r.headers={},e.headers&&(r.headers=e.headers);const n=e.dataType&&e.dataType.toLowerCase()==="json";return n&&(r.headers.Accept="application/json, text/javascript, */*; q=0.01"),fetch(t.toString(),r).then(o=>{if(o.status>=200&&o.status<300){const i=o.headers.get("content-type");return n||i&&i.indexOf("application/json")!==-1?o.json():o.text()}else return Promise.reject(new u(o.status.toString(),o.statusText))})}}const ee=".well-known",te="openid-configuration";class w{constructor(e){this.authorizationEndpoint=e.authorization_endpoint,this.tokenEndpoint=e.token_endpoint,this.revocationEndpoint=e.revocation_endpoint,this.userInfoEndpoint=e.userinfo_endpoint,this.endSessionEndpoint=e.end_session_endpoint}toJson(){return{authorization_endpoint:this.authorizationEndpoint,token_endpoint:this.tokenEndpoint,revocation_endpoint:this.revocationEndpoint,end_session_endpoint:this.endSessionEndpoint,userinfo_endpoint:this.userInfoEndpoint}}static fetchFromIssuer(e,t){const r=`${e}/${ee}/${te}`;return(t||new g).xhr({url:r,dataType:"json",method:"GET"}).then(n=>new w(n))}}class f{parse(e,t){return t?this.parseQueryString(e.hash):this.parseQueryString(e.search)}parseQueryString(e){const t={};e=e.trim().replace(/^(\?|#|&)/,"");const r=e.split("&");for(let n=0;n<r.length;n+=1){const o=r[n].split("=");if(o.length>=2){const i=decodeURIComponent(o.shift()),a=o.length>0?o.join("="):null;a&&(t[i]=decodeURIComponent(a))}}return t}stringify(e){const t=[];for(const r in e)Object.prototype.hasOwnProperty.call(e,r)&&e[r]&&t.push(`${encodeURIComponent(r)}=${encodeURIComponent(e[r])}`);return t.join("&")}}class C{}class b extends C{constructor(e){super(),this.storage=e||window.localStorage}getItem(e){return new Promise((t,r)=>{const n=this.storage.getItem(e);t(n||null)})}removeItem(e){return new Promise((t,r)=>{this.storage.removeItem(e),t()})}clear(){return new Promise((e,t)=>{this.storage.clear(),e()})}setItem(e,t){return new Promise((r,n)=>{this.storage.setItem(e,t),r()})}}const m=s=>`${s}_appauth_authorization_request`,j=s=>`${s}_appauth_authorization_service_configuration`,y="appauth_current_authorization_request";class re extends q{constructor(e=new b,t=new f,r=window.location,n=new p){super(t,n),this.storageBackend=e,this.locationLike=r}performAuthorizationRequest(e,t){const r=this.crypto.generateRandom(10);return Promise.all([this.storageBackend.setItem(y,r),t.toJson().then(n=>this.storageBackend.setItem(m(r),JSON.stringify(n))),this.storageBackend.setItem(j(r),JSON.stringify(e.toJson()))]).then(()=>{const n=this.buildRequestUrl(e,t);return h("Making a request to ",t,n),n})}completeAuthorizationRequest(){return this.storageBackend.getItem(y).then(e=>e?this.storageBackend.getItem(m(e)).then(t=>JSON.parse(t)).then(t=>new A(t)).then(t=>{const r=`${this.locationLike.origin}${this.locationLike.pathname}`,n=this.utils.parse(this.locationLike,!0),o=n.state,i=n.code,a=n.error;h("Potential authorization request ",r,n,o,i,a);const J=o===t.state;let T=null,R=null;if(J){if(a){const D=n.error_uri,$=n.error_description;R=new U({error:a,error_description:$,error_uri:D,state:o})}else T=new O({code:i,state:o});return Promise.all([this.storageBackend.removeItem(y),this.storageBackend.removeItem(m(e)),this.storageBackend.removeItem(j(e))]).then(()=>(h("Delivering authorization response"),{request:t,response:T,error:R}))}else return h("Mismatched request (state and request_uri) dont match."),Promise.resolve(null)}):null)}}class se{constructor(e){this.token=e.token,this.tokenTypeHint=e.token_type_hint,this.clientId=e.client_id,this.clientSecret=e.client_secret}toJson(){const e={token:this.token};return this.tokenTypeHint&&(e.token_type_hint=this.tokenTypeHint),this.clientId&&(e.client_id=this.clientId),this.clientSecret&&(e.client_secret=this.clientSecret),e}toStringMap(){return this.toJson()}}const ne="authorization_code",oe="refresh_token";class ie{constructor(e){this.clientId=e.client_id,this.redirectUri=e.redirect_uri,this.grantType=e.grant_type,this.code=e.code,this.refreshToken=e.refresh_token,this.extras=e.extras}toJson(){return{grant_type:this.grantType,code:this.code,refresh_token:this.refreshToken,redirect_uri:this.redirectUri,client_id:this.clientId,extras:this.extras}}toStringMap(){const e={grant_type:this.grantType,client_id:this.clientId,redirect_uri:this.redirectUri};if(this.code&&(e.code=this.code),this.refreshToken&&(e.refresh_token=this.refreshToken),this.extras)for(const t in this.extras)Object.prototype.hasOwnProperty.call(this.extras,t)&&!Object.prototype.hasOwnProperty.call(e,t)&&(e[t]=this.extras[t]);return e}}const k=()=>Math.round(new Date().getTime()/1e3);class N{constructor(e){this.accessToken=e.access_token,this.tokenType=e.token_type||"bearer",e.expires_in&&(this.expiresIn=parseInt(e.expires_in,10)),this.refreshToken=e.refresh_token,this.scope=e.scope,this.idToken=e.id_token,this.issuedAt=e.issued_at||k()}toJson(){return{access_token:this.accessToken,id_token:this.idToken,refresh_token:this.refreshToken,scope:this.scope,token_type:this.tokenType,issued_at:this.issuedAt,expires_in:this.expiresIn?.toString()}}isValid(e=0){return this.expiresIn?k()<this.issuedAt+this.expiresIn+e:!0}}class B{constructor(e){this.error=e.error,this.errorDescription=e.error_description,this.errorUri=e.error_uri}toJson(){return{error:this.error,error_description:this.errorDescription,error_uri:this.errorUri}}}class ae{constructor(e=new g,t=new f){this.requestor=e,this.utils=t}isTokenResponse(e){return e.error===void 0}performRevokeTokenRequest(e,t){return this.requestor.xhr({url:e.revocationEndpoint,method:"POST",headers:{"Content-Type":"application/x-www-form-urlencoded"},data:this.utils.stringify(t.toStringMap())}).then(r=>!0)}performTokenRequest(e,t){return this.requestor.xhr({url:e.tokenEndpoint,method:"POST",dataType:"json",headers:{"Content-Type":"application/x-www-form-urlencoded"},data:this.utils.stringify(t.toStringMap())}).then(r=>this.isTokenResponse(r)?new N(r):Promise.reject(new u(r.error,new B(r))))}}export{u as AppAuthError,U as AuthorizationError,X as AuthorizationNotifier,A as AuthorizationRequest,q as AuthorizationRequestHandler,O as AuthorizationResponse,w as AuthorizationServiceConfiguration,v as BUILT_IN_PARAMETERS,ae as BaseTokenRequestHandler,f as BasicQueryStringUtils,p as DefaultCrypto,g as FetchRequestor,ne as GRANT_TYPE_AUTHORIZATION_CODE,oe as GRANT_TYPE_REFRESH_TOKEN,K as IS_LOG,Q as IS_PROFILE,b as LocalStorageBackend,re as RedirectRequestHandler,z as Requestor,se as RevokeTokenRequest,C as StorageBackend,B as TokenError,ie as TokenRequest,N as TokenResponse,E as bufferToString,h as log,k as nowInSeconds,V as profile,P as textEncodeLite,S as urlSafe};
