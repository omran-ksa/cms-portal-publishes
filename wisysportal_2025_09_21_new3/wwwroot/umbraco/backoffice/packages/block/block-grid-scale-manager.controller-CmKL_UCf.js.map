{"version":3,"file":"block-grid-scale-manager.controller-CmKL_UCf.js","sources":["../../../src/packages/block/block-grid/utils/index.ts","../../../src/packages/block/block-grid/context/block-grid-scale-manager/block-grid-scale-manager.controller.ts"],"sourcesContent":["import type { UmbBlockGridLayoutModel } from '../types.js';\r\n\r\n/**\r\n *\r\n * @param {number} target - The target number\r\n * @param {Array<number>} map - The map to search in\r\n * @param {number} max - The max value to return if no match is found\r\n * @returns {number | undefined} - The closest number in the map to the target\r\n */\r\nexport function closestColumnSpanOption(target: number, map: Array<number>, max: number): number | undefined {\r\n\tif (map.length > 0) {\r\n\t\tconst result = map.reduce((a, b) => {\r\n\t\t\tif (a > max) {\r\n\t\t\t\treturn b;\r\n\t\t\t}\r\n\t\t\tconst aDiff = Math.abs(a - target);\r\n\t\t\tconst bDiff = Math.abs(b - target);\r\n\r\n\t\t\tif (aDiff === bDiff) {\r\n\t\t\t\treturn a < b ? a : b;\r\n\t\t\t} else {\r\n\t\t\t\treturn bDiff < aDiff ? b : a;\r\n\t\t\t}\r\n\t\t});\r\n\t\tif (result) {\r\n\t\t\treturn result;\r\n\t\t}\r\n\t}\r\n\treturn;\r\n}\r\n\r\n/**\r\n *\r\n * @param {UmbBlockGridLayoutModel} entry - The entry to iterate over\r\n * @param {(entry:UmbBlockGridLayoutModel) => void } callback - The callback to call for each entry\r\n */\r\nexport async function forEachBlockLayoutEntryOf(\r\n\tentry: UmbBlockGridLayoutModel,\r\n\tcallback: (entry: UmbBlockGridLayoutModel, parentUnique: string, areaKey: string) => PromiseLike<void>,\r\n): Promise<void> {\r\n\tif (entry.areas) {\r\n\t\tconst parentUnique = entry.contentKey;\r\n\t\tawait Promise.all(\r\n\t\t\tentry.areas.map(async (area) => {\r\n\t\t\t\tconst areaKey = area.key;\r\n\t\t\t\tawait Promise.all(\r\n\t\t\t\t\tarea.items.map(async (item) => {\r\n\t\t\t\t\t\tawait callback(item, parentUnique, areaKey);\r\n\t\t\t\t\t\tawait forEachBlockLayoutEntryOf(item, callback);\r\n\t\t\t\t\t}),\r\n\t\t\t\t);\r\n\t\t\t}),\r\n\t\t);\r\n\t}\r\n}\r\n","import { closestColumnSpanOption } from '../../utils/index.js';\r\nimport { getAccumulatedValueOfIndex, getInterpolatedIndexOfPositionInWeightMap } from '@umbraco-cms/backoffice/utils';\r\nimport { UmbControllerBase } from '@umbraco-cms/backoffice/class-api';\r\nimport type { UmbControllerHost } from '@umbraco-cms/backoffice/controller-api';\r\n\r\n// This might be more generic than Block Grid, but this is where it belongs currently:\r\nexport interface UmbBlockGridScalableContext extends UmbControllerHost {\r\n\tsetColumnSpan: (columnSpan: number) => void;\r\n\tsetRowSpan: (rowSpan: number) => void;\r\n\tgetColumnSpan: () => number | undefined;\r\n\tgetRowSpan: () => number | undefined;\r\n\tgetMinMaxRowSpan: () => [number, number] | undefined;\r\n\tgetRelevantColumnSpanOptions: () => Array<number> | undefined;\r\n}\r\n\r\n// This might be more generic than Block Grid, but this is where it belongs currently:\r\nexport interface UmbBlockGridScalableContainerContext extends UmbControllerHost {\r\n\tgetLayoutColumns: () => number | undefined;\r\n\tgetLayoutContainerElement: () => HTMLElement | undefined;\r\n}\r\n\r\nexport class UmbBlockGridScaleManager extends UmbControllerBase {\r\n\t//\r\n\t#runtimeGridColumns: Array<number> = [];\r\n\t#runtimeGridRows: Array<number> = [];\r\n\t#lockedGridRows = 0;\r\n\t//\r\n\toverride _host: UmbBlockGridScalableContext;\r\n\t_entries?: UmbBlockGridScalableContainerContext;\r\n\r\n\tconstructor(host: UmbBlockGridScalableContext) {\r\n\t\tsuper(host, 'blockGridScaleManager');\r\n\t\tthis._host = host;\r\n\t}\r\n\r\n\tsetEntriesContext(entriesContext: UmbBlockGridScalableContainerContext | undefined) {\r\n\t\tthis._entries = entriesContext;\r\n\t}\r\n\r\n\t// Scaling feature:\r\n\r\n\t#updateGridData(\r\n\t\tlayoutContainer: HTMLElement,\r\n\t\tlayoutContainerRect: DOMRect,\r\n\t\tlayoutItemRect: DOMRect,\r\n\t\tupdateRowTemplate: boolean,\r\n\t) {\r\n\t\tif (!this._entries) return;\r\n\t\tconst layoutColumns = this._entries.getLayoutColumns() ?? 0;\r\n\r\n\t\tconst computedStyles = window.getComputedStyle(layoutContainer);\r\n\r\n\t\tconst columnGap = Number(computedStyles.columnGap.split('px')[0]) || 0;\r\n\t\tconst rowGap = Number(computedStyles.rowGap.split('px')[0]) || 0;\r\n\r\n\t\tlet gridColumns = computedStyles.gridTemplateColumns\r\n\t\t\t.trim()\r\n\t\t\t.split('px')\r\n\t\t\t.map((x) => Number(x));\r\n\t\tlet gridRows = computedStyles.gridTemplateRows\r\n\t\t\t.trim()\r\n\t\t\t.split('px')\r\n\t\t\t.map((x) => Number(x));\r\n\r\n\t\t// remove empties:\r\n\t\tgridColumns = gridColumns.filter((n) => n > 0);\r\n\t\tgridRows = gridRows.filter((n) => n > 0);\r\n\r\n\t\t// We use this code to lock the templateRows, while scaling. otherwise scaling Rows is too crazy.\r\n\t\tif (updateRowTemplate || gridRows.length > this.#lockedGridRows) {\r\n\t\t\tthis.#lockedGridRows = gridRows.length;\r\n\t\t\tlayoutContainer.style.gridTemplateRows = computedStyles.gridTemplateRows;\r\n\t\t}\r\n\r\n\t\t// add gaps:\r\n\t\tconst gridColumnsLen = gridColumns.length;\r\n\t\tgridColumns = gridColumns.map((n, i) => (gridColumnsLen === i ? n : n + columnGap));\r\n\t\tconst gridRowsLen = gridRows.length;\r\n\t\tgridRows = gridRows.map((n, i) => (gridRowsLen === i ? n : n + rowGap));\r\n\r\n\t\t// ensure all columns are there.\r\n\t\t// This will also ensure handling non-css-grid mode,\r\n\t\t// use container width divided by amount of columns( or the item width divided by its amount of columnSpan)\r\n\t\tlet amountOfColumnsInWeightMap = gridColumns.length;\r\n\t\tconst amountOfUnknownColumns = layoutColumns - amountOfColumnsInWeightMap;\r\n\t\tif (amountOfUnknownColumns > 0) {\r\n\t\t\tconst accumulatedValue = getAccumulatedValueOfIndex(amountOfColumnsInWeightMap, gridColumns) || 0;\r\n\t\t\tconst missingColumnWidth = (layoutContainerRect.width - accumulatedValue) / amountOfUnknownColumns;\r\n\t\t\twhile (amountOfColumnsInWeightMap++ < layoutColumns) {\r\n\t\t\t\tgridColumns.push(missingColumnWidth);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Handle non css grid mode for Rows:\r\n\t\t// use item height divided by rowSpan to identify row heights.\r\n\t\tif (gridRows.length === 0) {\r\n\t\t\t// Push its own height twice, to give something to scale with.\r\n\t\t\tgridRows.push(layoutItemRect.top - layoutContainerRect.top);\r\n\r\n\t\t\tlet i = 0;\r\n\t\t\tconst itemSingleRowHeight = layoutItemRect.height;\r\n\t\t\twhile (i++ < (this._host.getRowSpan() ?? 0)) {\r\n\t\t\t\tgridRows.push(itemSingleRowHeight);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// add a few extra rows, so there is something to extend too.\r\n\t\t// Add extra options for the ability to extend beyond current content:\r\n\t\tgridRows.push(50);\r\n\t\tgridRows.push(50);\r\n\t\tgridRows.push(50);\r\n\t\tgridRows.push(50);\r\n\t\tgridRows.push(50);\r\n\r\n\t\tthis.#runtimeGridColumns = gridColumns;\r\n\t\tthis.#runtimeGridRows = gridRows;\r\n\t}\r\n\r\n\t// TODO: Rename to calc something.\r\n\t#getNewSpans(startX: number, startY: number, endX: number, endY: number) {\r\n\t\tconst layoutColumns = this._entries?.getLayoutColumns();\r\n\t\tif (!layoutColumns) return;\r\n\r\n\t\tconst blockStartCol = Math.round(getInterpolatedIndexOfPositionInWeightMap(startX, this.#runtimeGridColumns));\r\n\t\tconst blockStartRow = Math.round(getInterpolatedIndexOfPositionInWeightMap(startY, this.#runtimeGridRows));\r\n\t\tconst blockEndCol = getInterpolatedIndexOfPositionInWeightMap(endX, this.#runtimeGridColumns);\r\n\t\tconst blockEndRow = getInterpolatedIndexOfPositionInWeightMap(endY, this.#runtimeGridRows);\r\n\r\n\t\tlet newColumnSpan = Math.max(blockEndCol - blockStartCol, 1);\r\n\r\n\t\tconst columnOptions = this._host.getRelevantColumnSpanOptions();\r\n\t\tif (!columnOptions) return;\r\n\r\n\t\t// Find nearest allowed Column:\r\n\t\tconst bestColumnSpanOption = closestColumnSpanOption(newColumnSpan, columnOptions, layoutColumns - blockStartCol);\r\n\t\tnewColumnSpan = bestColumnSpanOption ?? layoutColumns;\r\n\r\n\t\t// Find allowed row spans:\r\n\t\tconst minMaxRowSpan = this._host.getMinMaxRowSpan();\r\n\t\tif (!minMaxRowSpan) return;\r\n\t\tconst [rowMinSpan, rowMaxSpan] = minMaxRowSpan;\r\n\t\tlet newRowSpan = Math.round(Math.max(blockEndRow - blockStartRow, rowMinSpan));\r\n\t\tif (rowMaxSpan != null) {\r\n\t\t\tnewRowSpan = Math.min(newRowSpan, rowMaxSpan);\r\n\t\t}\r\n\r\n\t\treturn { columnSpan: newColumnSpan, rowSpan: newRowSpan, startCol: blockStartCol, startRow: blockStartRow };\r\n\t}\r\n\r\n\tpublic onScaleMouseDown(event: MouseEvent) {\r\n\t\tconst layoutContainer = this._entries?.getLayoutContainerElement();\r\n\t\tif (!layoutContainer) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tevent.preventDefault();\r\n\r\n\t\t//this.#isScaleMode = true;\r\n\r\n\t\twindow.addEventListener('mousemove', this.onScaleMouseMove);\r\n\t\twindow.addEventListener('mouseup', this.onScaleMouseUp);\r\n\t\twindow.addEventListener('mouseleave', this.onScaleMouseUp);\r\n\r\n\t\tconst layoutItemRect = this.getHostElement().getBoundingClientRect();\r\n\t\tthis.#updateGridData(layoutContainer, layoutContainer.getBoundingClientRect(), layoutItemRect, true);\r\n\r\n\t\t/*\r\n\t\tscaleBoxBackdropEl = document.createElement('div');\r\n\t\tscaleBoxBackdropEl.className = 'umb-block-grid__scalebox-backdrop';\r\n\t\tlayoutContainer.appendChild(scaleBoxBackdropEl);\r\n\t\t*/\r\n\t}\r\n\r\n\t#updateLayoutRaf = 0;\r\n\tonScaleMouseMove = (e: MouseEvent) => {\r\n\t\tconst layoutContainer = this._entries?.getLayoutContainerElement();\r\n\t\tif (!layoutContainer) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tconst layoutContainerRect = layoutContainer.getBoundingClientRect();\r\n\t\tconst layoutItemRect = this.getHostElement().getBoundingClientRect();\r\n\r\n\t\tconst startX = layoutItemRect.left - layoutContainerRect.left;\r\n\t\tconst startY = layoutItemRect.top - layoutContainerRect.top;\r\n\t\tconst endX = e.clientX - layoutContainerRect.left;\r\n\t\tconst endY = e.clientY - layoutContainerRect.top;\r\n\r\n\t\tconst newSpans = this.#getNewSpans(startX, startY, endX, endY);\r\n\t\tif (!newSpans) return;\r\n\r\n\t\tconst updateRowTemplate = this._host.getColumnSpan() !== newSpans.columnSpan;\r\n\t\tif (updateRowTemplate) {\r\n\t\t\t// If we like to update we need to first remove the lock, make the browser render onces and then update.\r\n\t\t\t(layoutContainer as HTMLElement).style.gridTemplateRows = '';\r\n\t\t}\r\n\t\tcancelAnimationFrame(this.#updateLayoutRaf);\r\n\t\tthis.#updateLayoutRaf = requestAnimationFrame(() => {\r\n\t\t\t// As mentioned above we need to wait until the browser has rendered DOM without the lock of gridTemplateRows.\r\n\t\t\tthis.#updateGridData(layoutContainer, layoutContainerRect, layoutItemRect, updateRowTemplate);\r\n\t\t});\r\n\r\n\t\t// update as we go:\r\n\t\tthis._host.setColumnSpan(newSpans.columnSpan);\r\n\t\tthis._host.setRowSpan(newSpans.rowSpan);\r\n\t};\r\n\r\n\tonScaleMouseUp = (e: MouseEvent) => {\r\n\t\tconst layoutContainer = this._entries?.getLayoutContainerElement();\r\n\t\tif (!layoutContainer) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tcancelAnimationFrame(this.#updateLayoutRaf);\r\n\r\n\t\t// Remove listeners:\r\n\t\twindow.removeEventListener('mousemove', this.onScaleMouseMove);\r\n\t\twindow.removeEventListener('mouseup', this.onScaleMouseUp);\r\n\t\twindow.removeEventListener('mouseleave', this.onScaleMouseUp);\r\n\r\n\t\tconst layoutContainerRect = layoutContainer.getBoundingClientRect();\r\n\t\tconst layoutItemRect = this.getHostElement().getBoundingClientRect();\r\n\r\n\t\tconst startX = layoutItemRect.left - layoutContainerRect.left;\r\n\t\tconst startY = layoutItemRect.top - layoutContainerRect.top;\r\n\t\tconst endX = e.clientX - layoutContainerRect.left;\r\n\t\tconst endY = e.clientY - layoutContainerRect.top;\r\n\t\tconst newSpans = this.#getNewSpans(startX, startY, endX, endY);\r\n\r\n\t\t// release the lock of gridTemplateRows:\r\n\t\t//layoutContainer.removeChild(scaleBoxBackdropEl);\r\n\t\t//this.scaleBoxBackdropEl = null;\r\n\t\tlayoutContainer.style.gridTemplateRows = '';\r\n\t\t//this.#isScaleMode = false;\r\n\r\n\t\t// Clean up variables:\r\n\t\t//this.layoutContainer = null;\r\n\t\t//this.gridColumns = [];\r\n\t\t//this.gridRows = [];\r\n\t\tthis.#lockedGridRows = 0;\r\n\r\n\t\tif (!newSpans) return;\r\n\t\t// Update block size:\r\n\t\tthis._host.setColumnSpan(newSpans.columnSpan);\r\n\t\tthis._host.setRowSpan(newSpans.rowSpan);\r\n\t};\r\n}\r\n\r\nexport default UmbBlockGridScaleManager;\r\n"],"names":["closestColumnSpanOption","target","map","max","result","a","b","aDiff","bDiff","forEachBlockLayoutEntryOf","entry","callback","parentUnique","area","areaKey","item","UmbBlockGridScaleManager","UmbControllerBase","host","#runtimeGridColumns","#runtimeGridRows","#lockedGridRows","#updateLayoutRaf","e","layoutContainer","layoutContainerRect","layoutItemRect","startX","startY","endX","endY","newSpans","#getNewSpans","updateRowTemplate","#updateGridData","entriesContext","layoutColumns","computedStyles","columnGap","rowGap","gridColumns","x","gridRows","n","gridColumnsLen","i","gridRowsLen","amountOfColumnsInWeightMap","amountOfUnknownColumns","accumulatedValue","getAccumulatedValueOfIndex","missingColumnWidth","itemSingleRowHeight","blockStartCol","getInterpolatedIndexOfPositionInWeightMap","blockStartRow","blockEndCol","blockEndRow","newColumnSpan","columnOptions","minMaxRowSpan","rowMinSpan","rowMaxSpan","newRowSpan","event"],"mappings":"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"}