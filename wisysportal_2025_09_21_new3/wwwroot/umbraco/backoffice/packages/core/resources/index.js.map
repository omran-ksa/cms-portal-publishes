{"version":3,"file":"index.js","sources":["../../../../src/packages/core/resources/extractUmbNotificationColor.function.ts","../../../../src/packages/core/resources/isUmbNotifications.function.ts","../../../../src/packages/core/resources/apiTypeValidators.function.ts","../../../../src/packages/core/resources/api-interceptor.controller.ts","../../../../src/packages/core/resources/umb-error.ts","../../../../src/packages/core/resources/resource.controller.ts","../../../../src/packages/core/resources/try-execute/try-execute.controller.ts","../../../../src/packages/core/resources/try-execute/tryExecute.function.ts","../../../../src/packages/core/resources/try-execute/batch-try-execute.function.ts","../../../../src/packages/core/resources/try-execute/tryExecuteAndNotify.function.ts","../../../../src/packages/core/resources/cancelable-promise.ts","../../../../src/packages/core/resources/try-execute/tryXhrRequest.function.ts"],"sourcesContent":["import type { UmbNotificationColor } from '../notification/types.js';\r\nimport { EventMessageTypeModel } from '@umbraco-cms/backoffice/external/backend-api';\r\n\r\n/**\r\n * Extracts the UmbNotificationColor from the EventMessageTypeModel.\r\n * @param {EventMessageTypeModel} type The EventMessageTypeModel to extract the color from.\r\n * @returns {UmbNotificationColor} The corresponding UmbNotificationColor.\r\n * @example\r\n * const color = extractUmbNotificationColor(EventMessageTypeModel.ERROR); // color will be 'danger'\r\n */\r\nexport function extractUmbNotificationColor(type: EventMessageTypeModel): UmbNotificationColor {\r\n\tswitch (type) {\r\n\t\tcase EventMessageTypeModel.ERROR:\r\n\t\t\treturn 'danger';\r\n\t\tcase EventMessageTypeModel.WARNING:\r\n\t\t\treturn 'warning';\r\n\t\tcase EventMessageTypeModel.INFO:\r\n\t\tcase EventMessageTypeModel.DEFAULT:\r\n\t\t\treturn 'default';\r\n\t\tcase EventMessageTypeModel.SUCCESS:\r\n\t\t\treturn 'positive';\r\n\t\tdefault:\r\n\t\t\treturn '';\r\n\t}\r\n}\r\n","import { EventMessageTypeModel } from '@umbraco-cms/backoffice/external/backend-api';\r\n\r\n/**\r\n *\r\n * @param notification\r\n */\r\nfunction objectIsUmbNotification(notification: unknown): notification is UmbNotificationsEventModel {\r\n\tif (typeof notification !== 'object' || notification === null) {\r\n\t\treturn false;\r\n\t}\r\n\tconst object = notification as UmbNotificationsEventModel;\r\n\treturn (\r\n\t\ttypeof object.category === 'string' &&\r\n\t\ttypeof object.message === 'string' &&\r\n\t\ttypeof object.type === 'string' &&\r\n\t\tObject.values(EventMessageTypeModel).includes(object.type)\r\n\t);\r\n}\r\n\r\nexport interface UmbNotificationsEventModel {\r\n\tcategory: string;\r\n\tmessage: string;\r\n\ttype: EventMessageTypeModel;\r\n}\r\n\r\n/**\r\n *\r\n * @param notifications\r\n */\r\nexport function isUmbNotifications(notifications: Array<unknown>): notifications is Array<UmbNotificationsEventModel> {\r\n\treturn notifications.every(objectIsUmbNotification);\r\n}\r\n\r\nexport const UMB_NOTIFICATION_HEADER = 'umb-notifications';\r\n","import type { UmbProblemDetails } from './types.js';\r\n\r\n/**\r\n * Checks if the given error is an instance of ApiError.\r\n * @param {*} error The error to check\r\n * @returns {boolean} True if the error is an instance of ApiError, false otherwise\r\n * @deprecated Use {UmbApiError.isUmbApiError} instead and map your object to {UmbApiError} if needed.\r\n */\r\nexport function isApiError(error: unknown): error is { body?: string; status?: number; request?: unknown } {\r\n\treturn typeof error === 'object' && error !== null && 'body' in error && 'status' in error && 'request' in error;\r\n}\r\n\r\n/**\r\n * Checks if the given error is an instance of CancelError.\r\n * @param {*} error The error to check\r\n * @returns {boolean} True if the error is an instance of CancelError, false otherwise\r\n * @deprecated Use {UmbApiCancelError.isUmbApiCancelError}` instead and map your object to {UmbApiCancelError} if needed.\r\n */\r\nexport function isCancelError(error: unknown): error is Error {\r\n\treturn error instanceof Error && (error.name === 'CancelError' || (error as Error).message === 'Request aborted');\r\n}\r\n\r\n/**\r\n * Checks if the given promise is cancelable, i.e. if it has a cancel method.\r\n * @param {*} promise The promise to check\r\n * @returns {boolean} True if the promise is cancelable, false otherwise\r\n */\r\nexport function isCancelablePromise<T>(promise: unknown): promise is Promise<T> & { cancel: () => void } {\r\n\treturn typeof (promise as Promise<T> & { cancel: () => void }).cancel === 'function';\r\n}\r\n\r\n/**\r\n * Checks if the given error is an instance of ProblemDetails.\r\n * @param {*} error The error to check\r\n * @returns {boolean} True if the error is an instance of ProblemDetails, false otherwise\r\n */\r\nexport function isProblemDetailsLike(error: unknown): error is UmbProblemDetails {\r\n\treturn (\r\n\t\ttypeof error === 'object' &&\r\n\t\terror !== null &&\r\n\t\t'type' in error &&\r\n\t\t'title' in error &&\r\n\t\t'status' in error &&\r\n\t\t(typeof (error as { detail?: unknown }).detail === 'undefined' ||\r\n\t\t\ttypeof (error as { detail?: unknown }).detail === 'string') &&\r\n\t\t(typeof (error as { instance?: unknown }).instance === 'undefined' ||\r\n\t\t\ttypeof (error as { instance?: unknown }).instance === 'string') &&\r\n\t\t(typeof (error as { operationStatus?: unknown }).operationStatus === 'undefined' ||\r\n\t\t\ttypeof (error as { operationStatus?: unknown }).operationStatus === 'string') &&\r\n\t\t(typeof (error as { errors?: unknown }).errors === 'undefined' ||\r\n\t\t\ttypeof (error as { errors?: unknown }).errors === 'object')\r\n\t);\r\n}\r\n","import { extractUmbNotificationColor } from './extractUmbNotificationColor.function.js';\r\nimport { isUmbNotifications, UMB_NOTIFICATION_HEADER } from './isUmbNotifications.function.js';\r\nimport { isProblemDetailsLike } from './apiTypeValidators.function.js';\r\nimport type { UmbProblemDetails } from './types.js';\r\nimport { UmbControllerBase } from '@umbraco-cms/backoffice/class-api';\r\nimport { UMB_AUTH_CONTEXT } from '@umbraco-cms/backoffice/auth';\r\nimport type { UmbNotificationColor } from '@umbraco-cms/backoffice/notification';\r\nimport type { RequestOptions, umbHttpClient } from '@umbraco-cms/backoffice/http-client';\r\n\r\nconst MAX_RETRIES = 3;\r\n\r\nexport class UmbApiInterceptorController extends UmbControllerBase {\r\n\t/**\r\n\t * Store pending requests that received a 401 response and are waiting for re-authentication.\r\n\t * This is used to retry the requests after re-authentication.\r\n\t */\r\n\t#pending401Requests: Array<{\r\n\t\trequest: Request;\r\n\t\trequestConfig: RequestOptions;\r\n\t\tretry: () => Promise<Response>;\r\n\t\tresolve: (value: Response) => void;\r\n\t\treject: (reason?: unknown) => void;\r\n\t\tretries: number;\r\n\t}> = [];\r\n\r\n\t/**\r\n\t * Store non-GET requests that received a 401 response.\r\n\t * This is used to notify the user about actions that could not be completed due to session expiration.\r\n\t * These requests will not be retried, as they are not idempotent.\r\n\t * Instead, we will notify the user about these requests after re-authentication.\r\n\t */\r\n\t#nonGet401Requests: Array<{ request: Request; requestConfig: RequestOptions }> = [];\r\n\r\n\t/**\r\n\t * Binds the default interceptors to the client.\r\n\t * This includes the auth response interceptor, the error interceptor and the umb-notifications interceptor.\r\n\t * @param {umbHttpClient} client The OpenAPI client to add the interceptor to. It can be any client supporting Response and Request interceptors.\r\n\t */\r\n\tpublic bindDefaultInterceptors(client: typeof umbHttpClient) {\r\n\t\t// Add the default observables to the instance\r\n\t\tthis.handleUnauthorizedAuthRetry();\r\n\t\t// Add the default interceptors to the client\r\n\t\tthis.addAuthResponseInterceptor(client);\r\n\t\tthis.addForbiddenResponseInterceptor(client);\r\n\t\tthis.addUmbGeneratedResourceInterceptor(client);\r\n\t\tthis.addUmbNotificationsInterceptor(client);\r\n\t\tthis.addErrorInterceptor(client);\r\n\t}\r\n\r\n\t/**\r\n\t * Interceptor which checks responses for 401 errors and lets the UmbAuthContext know the user is timed out.\r\n\t * @param {umbHttpClient} client The OpenAPI client to add the interceptor to. It can be any client supporting Response and Request interceptors.\r\n\t * @internal\r\n\t */\r\n\taddAuthResponseInterceptor(client: typeof umbHttpClient) {\r\n\t\tclient.interceptors.response.use(async (response, request, requestConfig): Promise<Response> => {\r\n\t\t\tif (response.status !== 401) return response;\r\n\r\n\t\t\t// Build a plain ProblemDetails object for the response body\r\n\t\t\tconst problemDetails: UmbProblemDetails = {\r\n\t\t\t\tstatus: response.status,\r\n\t\t\t\ttitle: response.statusText || 'Unauthorized request, waiting for re-authentication.',\r\n\t\t\t\tdetail: undefined,\r\n\t\t\t\terrors: undefined,\r\n\t\t\t\ttype: 'Unauthorized',\r\n\t\t\t\tstack: undefined,\r\n\t\t\t};\r\n\r\n\t\t\tconst newResponse = this.#createResponse(problemDetails, response);\r\n\r\n\t\t\tconst authContext = await this.getContext(UMB_AUTH_CONTEXT, { preventTimeout: true });\r\n\t\t\tif (!authContext) throw new Error('Could not get the auth context');\r\n\r\n\t\t\t// Only retry for GET requests\r\n\t\t\tif (request.method !== 'GET') {\r\n\t\t\t\t// Collect info for later notification\r\n\t\t\t\tthis.#nonGet401Requests.push({ request, requestConfig });\r\n\r\n\t\t\t\t// Show login overlay (only once per burst, as before)\r\n\t\t\t\tauthContext.timeOut();\r\n\t\t\t\treturn newResponse;\r\n\t\t\t}\r\n\r\n\t\t\t// Find if this request is already in the queue and increment retries\r\n\t\t\tlet retries = 1;\r\n\t\t\tconst existing = this.#pending401Requests.find(\r\n\t\t\t\t(req) => req.request === request && req.requestConfig === requestConfig,\r\n\t\t\t);\r\n\t\t\tif (existing) {\r\n\t\t\t\tretries = existing.retries + 1;\r\n\t\t\t\tif (retries > MAX_RETRIES) {\r\n\t\t\t\t\treturn newResponse;\r\n\t\t\t\t}\r\n\t\t\t\texisting.retries = retries;\r\n\t\t\t}\r\n\r\n\t\t\t// Return a promise that will resolve when re-auth completes\r\n\t\t\treturn new Promise<Response>((resolve, reject) => {\r\n\t\t\t\tthis.#pending401Requests.push({\r\n\t\t\t\t\trequest,\r\n\t\t\t\t\trequestConfig,\r\n\t\t\t\t\tretry: async () => {\r\n\t\t\t\t\t\tconst { data, response: retryResponse } = await client.request(requestConfig as never);\r\n\r\n\t\t\t\t\t\treturn this.#createResponse(data, retryResponse);\r\n\t\t\t\t\t},\r\n\t\t\t\t\tresolve,\r\n\t\t\t\t\treject,\r\n\t\t\t\t\tretries,\r\n\t\t\t\t});\r\n\r\n\t\t\t\t// Show login overlay\r\n\t\t\t\tauthContext.timeOut();\r\n\r\n\t\t\t\tconsole.log(\r\n\t\t\t\t\t'[Interceptor] 401 Unauthorized - queuing request for re-authentication and have tried',\r\n\t\t\t\t\tretries - 1,\r\n\t\t\t\t\t'times before',\r\n\t\t\t\t\trequestConfig,\r\n\t\t\t\t);\r\n\t\t\t});\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Interceptor which checks responses for 403 errors and displays them as a notification.\r\n\t * @param {umbHttpClient} client The OpenAPI client to add the interceptor to. It can be any client supporting Response and Request interceptors.\r\n\t * @internal\r\n\t */\r\n\taddForbiddenResponseInterceptor(client: typeof umbHttpClient) {\r\n\t\tclient.interceptors.response.use((response): Response => {\r\n\t\t\tif (response.status !== 403) return response;\r\n\r\n\t\t\t// Build a plain ProblemDetails object for the response body\r\n\t\t\tconst problemDetails: UmbProblemDetails = {\r\n\t\t\t\tstatus: response.status,\r\n\t\t\t\ttitle:\r\n\t\t\t\t\tresponse.statusText ||\r\n\t\t\t\t\t'You do not have the necessary permissions to complete the requested action. If you believe this is in error, please reach out to your administrator.',\r\n\t\t\t\tdetail: undefined,\r\n\t\t\t\terrors: undefined,\r\n\t\t\t\ttype: 'Unauthorized',\r\n\t\t\t\tstack: undefined,\r\n\t\t\t};\r\n\r\n\t\t\treturn this.#createResponse(problemDetails, response);\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Interceptor which checks responses for the Umb-Generated-Resource header and replaces the value into the response body.\r\n\t * @param {umbHttpClient} client The OpenAPI client to add the interceptor to. It can be any client supporting Response and Request interceptors.\r\n\t * @internal\r\n\t */\r\n\taddUmbGeneratedResourceInterceptor(client: typeof umbHttpClient) {\r\n\t\tclient.interceptors.response.use((response): Response => {\r\n\t\t\tif (!response.headers.has('Umb-Generated-Resource')) return response;\r\n\r\n\t\t\tconst generatedResource = response.headers.get('Umb-Generated-Resource');\r\n\t\t\tif (generatedResource === null) {\r\n\t\t\t\treturn response;\r\n\t\t\t}\r\n\r\n\t\t\t// Return a new response with the generated resource in the body (plain text)\r\n\t\t\treturn this.#createResponse(generatedResource, response);\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Interceptor which checks responses for 500 errors and displays them as a notification if any.\r\n\t * @param {umbHttpClient} client The OpenAPI client to add the interceptor to. It can be any client supporting Response and Request interceptors.\r\n\t * @internal\r\n\t */\r\n\taddErrorInterceptor(client: typeof umbHttpClient) {\r\n\t\tclient.interceptors.response.use(async (response): Promise<Response> => {\r\n\t\t\t// If the response is ok, we just return the response\r\n\t\t\tif (response.ok) return response;\r\n\r\n\t\t\t// We will check if it is not a 401 or 403 error, as that is handled by other interceptors\r\n\t\t\tif (response.status === 401 || response.status === 403) return response;\r\n\r\n\t\t\t// Special handling for 404 Not Found\r\n\t\t\tif (response.status === 404) {\r\n\t\t\t\tconst notFoundProblemDetails: UmbProblemDetails = {\r\n\t\t\t\t\tstatus: response.status,\r\n\t\t\t\t\ttitle: response.statusText || 'The requested resource was not found.',\r\n\t\t\t\t\tdetail: undefined,\r\n\t\t\t\t\terrors: undefined,\r\n\t\t\t\t\ttype: 'NotFound',\r\n\t\t\t\t\tstack: undefined,\r\n\t\t\t\t};\r\n\t\t\t\treturn this.#createResponse(notFoundProblemDetails, response);\r\n\t\t\t}\r\n\r\n\t\t\t// For all other errors, we will build a ProblemDetails object\r\n\t\t\tlet problemDetails: UmbProblemDetails = {\r\n\t\t\t\tstatus: response.status,\r\n\t\t\t\ttitle:\r\n\t\t\t\t\tresponse.statusText ||\r\n\t\t\t\t\t'A fatal server error occurred. If this continues, please reach out to your administrator.',\r\n\t\t\t\tdetail: undefined,\r\n\t\t\t\terrors: undefined,\r\n\t\t\t\ttype: 'ServerError',\r\n\t\t\t\tstack: undefined,\r\n\t\t\t};\r\n\r\n\t\t\ttry {\r\n\t\t\t\t// Clones the response to read the body\r\n\t\t\t\tconst origResponse = response.clone();\r\n\t\t\t\tconst errorBody = await origResponse.json();\r\n\r\n\t\t\t\t// If there is JSON in the error, we will try to parse it as a ProblemDetails object\r\n\t\t\t\tif (errorBody && isProblemDetailsLike(errorBody)) {\r\n\t\t\t\t\t// Merge the parsed problem details into our default\r\n\t\t\t\t\tproblemDetails = errorBody;\r\n\t\t\t\t}\r\n\t\t\t} catch (e) {\r\n\t\t\t\t// Ignore JSON parse error\r\n\t\t\t\tconsole.error('[Interceptor] Caught a server error, but failed parsing error body (expected JSON)', e);\r\n\t\t\t}\r\n\r\n\t\t\treturn this.#createResponse(problemDetails, response);\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Interceptor which checks responses for the umb-notifications header and displays them as a notification if any. Removes the umb-notifications from the headers.\r\n\t * @param {umbHttpClient} client The OpenAPI client to add the interceptor to. It can be any client supporting Response and Request interceptors.\r\n\t * @internal\r\n\t */\r\n\taddUmbNotificationsInterceptor(client: typeof umbHttpClient) {\r\n\t\tclient.interceptors.response.use((response) => {\r\n\t\t\t// Check if the response has the umb-notifications header\r\n\t\t\t// If not, we just return the response\r\n\t\t\tconst umbNotifications = response.headers.get(UMB_NOTIFICATION_HEADER);\r\n\t\t\tif (!umbNotifications) return response;\r\n\r\n\t\t\t// Parse the notifications from the header\r\n\t\t\t// If the header is not a valid JSON, we just return the response\r\n\t\t\ttry {\r\n\t\t\t\tconst notifications = JSON.parse(umbNotifications);\r\n\t\t\t\tif (!isUmbNotifications(notifications)) return response;\r\n\r\n\t\t\t\tfor (const notification of notifications) {\r\n\t\t\t\t\tthis.#peekError(\r\n\t\t\t\t\t\tnotification.category,\r\n\t\t\t\t\t\tnotification.message,\r\n\t\t\t\t\t\tnull,\r\n\t\t\t\t\t\textractUmbNotificationColor(notification.type),\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\t\t\t} catch {\r\n\t\t\t\t// Ignore JSON parse errors\r\n\t\t\t}\r\n\r\n\t\t\treturn response;\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Listen for authorization signal to retry GET-requests that received a 401 Unauthorized response.\r\n\t * This will retry all pending requests that received a 401 Unauthorized response after re-authentication.\r\n\t * It will also notify the user about non-GET requests that received a 401 Unauthorized response.\r\n\t * @internal\r\n\t */\r\n\thandleUnauthorizedAuthRetry() {\r\n\t\tthis.consumeContext(UMB_AUTH_CONTEXT, (context) => {\r\n\t\t\tthis.observe(\r\n\t\t\t\tcontext?.authorizationSignal,\r\n\t\t\t\t() => {\r\n\t\t\t\t\tconsole.log('[Interceptor] 401 Unauthorized - re-authentication completed');\r\n\r\n\t\t\t\t\t// On auth, retry all pending requests\r\n\t\t\t\t\tconst requests = this.#pending401Requests.splice(0, this.#pending401Requests.length);\r\n\t\t\t\t\trequests.forEach((req) => {\r\n\t\t\t\t\t\tconsole.log('[Interceptor] 401 Unauthorized - retrying request after re-authentication', req.requestConfig);\r\n\t\t\t\t\t\treq.retry().then(req.resolve).catch(req.reject);\r\n\t\t\t\t\t});\r\n\r\n\t\t\t\t\t// Notify about non-GET 401s after successful re-auth\r\n\t\t\t\t\tif (this.#nonGet401Requests.length > 0) {\r\n\t\t\t\t\t\tconst errors: Record<string, string> = {};\r\n\t\t\t\t\t\tthis.#nonGet401Requests.forEach((req) => {\r\n\t\t\t\t\t\t\terrors[`${req.request.method} ${req.request.url}`] = `Request failed with 401 Unauthorized.`;\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t\tthis.#peekError(\r\n\t\t\t\t\t\t\t'Some actions were not completed',\r\n\t\t\t\t\t\t\t'Some actions could not be completed because your session expired. Please try again.',\r\n\t\t\t\t\t\t\terrors,\r\n\t\t\t\t\t\t\t'warning',\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t\tthis.#nonGet401Requests.length = 0; // Clear after notifying\r\n\t\t\t\t\t}\r\n\t\t\t\t},\r\n\t\t\t\t'_authClearNonGet401Requests',\r\n\t\t\t);\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Helper to create a new Response with correct Content-Type.\r\n\t * @param {unknown} body The body of the response, can be a string or an object.\r\n\t * @param {Response} originalResponse The original response to copy status and headers from.\r\n\t * @returns {Response} The new Response object with the correct Content-Type and body.\r\n\t */\r\n\t#createResponse(body: unknown, originalResponse: Response): Response {\r\n\t\tconst isString = typeof body === 'string';\r\n\t\tconst contentType = isString ? 'text/plain' : 'application/json';\r\n\t\tconst responseBody = isString ? body : JSON.stringify(body);\r\n\r\n\t\t// Construct new headers but preserve \"X-\" headers from the original response\r\n\t\tconst headersOverride: Record<string, string> = {};\r\n\t\toriginalResponse.headers.forEach((value, key) => {\r\n\t\t\tif (key.toLowerCase().startsWith('x-')) {\r\n\t\t\t\theadersOverride[key] = value;\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\treturn new Response(responseBody, {\r\n\t\t\tstatus: originalResponse.status,\r\n\t\t\tstatusText: originalResponse.statusText,\r\n\t\t\theaders: {\r\n\t\t\t\t...headersOverride,\r\n\t\t\t\t'Content-Type': contentType,\r\n\t\t\t},\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Helper to show a notification error.\r\n\t */\r\n\tasync #peekError(headline: string, message: string, details: unknown, color?: UmbNotificationColor) {\r\n\t\t// Store the host for usage in the following async context\r\n\t\tconst host = this._host;\r\n\r\n\t\t// This late importing is done to avoid circular reference [NL]\r\n\t\t(await import('@umbraco-cms/backoffice/notification')).umbPeekError(host, {\r\n\t\t\theadline,\r\n\t\t\tmessage,\r\n\t\t\tdetails,\r\n\t\t\tcolor,\r\n\t\t});\r\n\t}\r\n}\r\n","import type { UmbProblemDetails } from './types.js';\r\n\r\nexport class UmbError extends Error {\r\n\tpublic override name = 'UmbError';\r\n\r\n\tpublic static isUmbError(error: unknown): error is UmbError {\r\n\t\treturn error instanceof UmbError || (error as UmbError).name === 'UmbError';\r\n\t}\r\n}\r\n\r\nexport class UmbCancelError extends UmbError {\r\n\tpublic override name = 'UmbCancelError';\r\n\r\n\tpublic static isUmbCancelError(error: unknown): error is UmbCancelError {\r\n\t\treturn error instanceof UmbCancelError || (error as UmbCancelError).name === 'UmbCancelError';\r\n\t}\r\n\r\n\t/**\r\n\t * Transforms a CancelError into an UmbCancelError.\r\n\t * @param {*} error The CancelError to transform.\r\n\t * @returns {UmbCancelError} The transformed UmbCancelError.\r\n\t * @deprecated Use `UmbCancelError.isUmbCancelError` instead and map your object to `UmbCancelError` if needed.\r\n\t */\r\n\tpublic static fromLegacyCancelError(error: Error): UmbCancelError {\r\n\t\treturn new UmbCancelError(error.message);\r\n\t}\r\n}\r\n\r\n/**\r\n * UmbApiError is a class that extends UmbError and represents an error that occurs during an API call.\r\n */\r\nexport class UmbApiError extends UmbError {\r\n\tpublic override name = 'UmbApiError';\r\n\tpublic status: number;\r\n\tpublic request: unknown;\r\n\tpublic problemDetails: UmbProblemDetails;\r\n\r\n\tpublic constructor(message: string, status: number, request: unknown, problemDetails: UmbProblemDetails) {\r\n\t\tsuper(message);\r\n\t\tthis.status = status;\r\n\t\tthis.request = request;\r\n\t\tthis.problemDetails = problemDetails;\r\n\t}\r\n\r\n\tpublic static isUmbApiError(error: unknown): error is UmbApiError {\r\n\t\treturn error instanceof UmbApiError || (error as UmbApiError).name === 'UmbApiError';\r\n\t}\r\n\r\n\t/**\r\n\t * Transforms an ApiError into an UmbApiError.\r\n\t * @param {*} error The ApiError to transform.\r\n\t * @returns {UmbApiError} The transformed UmbApiError.\r\n\t * @deprecated Use `UmbCancelError.isUmbApiError` instead and map your object to `UmbApiError` if needed.\r\n\t */\r\n\tpublic static fromLegacyApiError(error: Error & { body?: string; status?: number; request?: unknown }): UmbApiError {\r\n\t\t// ApiError - body could hold a ProblemDetails from the server\r\n\t\tlet problemDetails: UmbProblemDetails | null = null;\r\n\t\tif (typeof error.body !== 'undefined' && !!error.body) {\r\n\t\t\ttry {\r\n\t\t\t\tproblemDetails = typeof error.body === 'string' ? JSON.parse(error.body) : error.body;\r\n\t\t\t} catch (e) {\r\n\t\t\t\tconsole.error('Error parsing error body (expected JSON)', e);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn new UmbApiError(\r\n\t\t\terror.message,\r\n\t\t\terror.status ?? 0,\r\n\t\t\terror.request,\r\n\t\t\tproblemDetails ?? { title: error.message, type: 'ApiError', status: error.status ?? 0 },\r\n\t\t);\r\n\t}\r\n}\r\n","import { isApiError, isCancelablePromise, isCancelError, isProblemDetailsLike } from './apiTypeValidators.function.js';\r\nimport { UmbApiError, UmbCancelError } from './umb-error.js';\r\nimport { UmbControllerBase } from '@umbraco-cms/backoffice/class-api';\r\nimport type { UmbControllerHost } from '@umbraco-cms/backoffice/controller-api';\r\n\r\nexport class UmbResourceController<T = unknown> extends UmbControllerBase {\r\n\t/**\r\n\t * The promise that is being executed.\r\n\t * @protected\r\n\t */\r\n\tprotected _promise;\r\n\r\n\tconstructor(host: UmbControllerHost, promise: PromiseLike<T>, alias?: string) {\r\n\t\tsuper(host, alias);\r\n\r\n\t\tthis._promise = promise;\r\n\t}\r\n\r\n\t/**\r\n\t * Maps any error to an UmbError.\r\n\t * @internal\r\n\t * @param {*} error The error to map\r\n\t * @returns {*} The mapped error\r\n\t */\r\n\tmapToUmbError(error: unknown): UmbApiError | UmbCancelError {\r\n\t\tif (isProblemDetailsLike(error)) {\r\n\t\t\treturn new UmbApiError(error.detail ?? error.title, error.status, null, error);\r\n\t\t} else if (isApiError(error)) {\r\n\t\t\treturn UmbApiError.fromLegacyApiError(error as never);\r\n\t\t} else if (isCancelError(error)) {\r\n\t\t\treturn UmbCancelError.fromLegacyCancelError(error);\r\n\t\t} else if (UmbCancelError.isUmbCancelError(error)) {\r\n\t\t\treturn error;\r\n\t\t} else if (UmbApiError.isUmbApiError(error)) {\r\n\t\t\treturn error;\r\n\t\t}\r\n\r\n\t\t// If the error is not recognizable, for example if it has no ProblemDetails body, we will return a generic UmbApiError.\r\n\t\t// This is to ensure that we always return an UmbApiError, so we can handle it in a consistent way.\r\n\t\treturn new UmbApiError(error instanceof Error ? error.message : 'Unknown error', 0, null, {\r\n\t\t\tstatus: 0,\r\n\t\t\ttitle: 'Unknown error',\r\n\t\t\tdetail: error instanceof Error ? error.message : 'Unknown error',\r\n\t\t\terrors: undefined,\r\n\t\t\ttype: 'error',\r\n\t\t\tstack: error instanceof Error ? error.stack : undefined,\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Cancel all resources that are currently being executed by this controller if they are cancelable.\r\n\t *\r\n\t * This works by checking if the promise is a CancelablePromise and if so, it will call the cancel method.\r\n\t *\r\n\t * This is useful when the controller is being disconnected from the DOM.\r\n\t * @see CancelablePromise\r\n\t * @see https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal\r\n\t * @see https://developer.mozilla.org/en-US/docs/Web/API/AbortController\r\n\t */\r\n\tcancel(): void {\r\n\t\tif (isCancelablePromise(this._promise)) {\r\n\t\t\tthis._promise.cancel();\r\n\t\t}\r\n\t}\r\n\r\n\toverride hostDisconnected(): void {\r\n\t\tsuper.hostDisconnected();\r\n\t\tthis.cancel();\r\n\t}\r\n\r\n\toverride destroy(): void {\r\n\t\tsuper.destroy();\r\n\t\tthis.cancel();\r\n\t}\r\n\r\n\tprotected async _peekError(headline: string, message: string, details: unknown) {\r\n\t\t// Store the host for usage in the following async context\r\n\t\tconst host = this._host;\r\n\r\n\t\t// This late importing is done to avoid circular reference\r\n\t\t(await import('@umbraco-cms/backoffice/notification')).umbPeekError(host, {\r\n\t\t\theadline,\r\n\t\t\tmessage,\r\n\t\t\tdetails,\r\n\t\t});\r\n\t}\r\n}\r\n","import { UmbResourceController } from '../resource.controller.js';\r\nimport type { UmbApiResponse, UmbTryExecuteOptions } from '../types.js';\r\nimport { UmbCancelError } from '../umb-error.js';\r\nimport type { UmbApiError } from '../umb-error.js';\r\n\r\n/**\r\n * Codes that are ignored for notifications.\r\n * These are typically non-fatal errors that the UI can handle gracefully,\r\n * such as 401 (Unauthorized), 403 (Forbidden), and 404 (Not Found).\r\n * The UI should handle these cases without showing a notification.\r\n */\r\nconst IGNORED_ERROR_CODES = [401, 403, 404];\r\n\r\nexport class UmbTryExecuteController<T> extends UmbResourceController<T> {\r\n\t#abortSignal?: AbortSignal;\r\n\r\n\tasync tryExecute(opts?: UmbTryExecuteOptions): Promise<UmbApiResponse<T>> {\r\n\t\ttry {\r\n\t\t\tif (opts?.abortSignal) {\r\n\t\t\t\tthis.#abortSignal = opts.abortSignal;\r\n\t\t\t\tthis.#abortSignal.addEventListener('abort', () => this.cancel(), { once: true });\r\n\t\t\t}\r\n\r\n\t\t\treturn (await this._promise) as UmbApiResponse<T>;\r\n\t\t} catch (error) {\r\n\t\t\t// Error might be a legacy error, so we need to check if it is an UmbError\r\n\t\t\tconst umbError = this.mapToUmbError(error);\r\n\r\n\t\t\tif (!opts?.disableNotifications) {\r\n\t\t\t\tthis.#notifyOnError(umbError);\r\n\t\t\t}\r\n\r\n\t\t\treturn {\r\n\t\t\t\terror: umbError,\r\n\t\t\t} as UmbApiResponse<T>;\r\n\t\t}\r\n\t}\r\n\r\n\toverride destroy(): void {\r\n\t\tif (this.#abortSignal) {\r\n\t\t\tthis.#abortSignal.removeEventListener('abort', this.cancel);\r\n\t\t}\r\n\t\tsuper.destroy();\r\n\t}\r\n\r\n\t#notifyOnError(error: UmbApiError | UmbCancelError): void {\r\n\t\tif (UmbCancelError.isUmbCancelError(error)) {\r\n\t\t\t// Cancel error, do not show notification\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tlet headline = 'An error occurred';\r\n\t\tlet message = 'A fatal server error occurred. If this continues, please reach out to your administrator.';\r\n\t\tlet details: Record<string, string[]> | undefined = undefined;\r\n\r\n\t\tconst apiError = error as UmbApiError;\r\n\r\n\t\t// Check if we can extract problem details from the error\r\n\t\tif (apiError.problemDetails) {\r\n\t\t\tif (IGNORED_ERROR_CODES.includes(apiError.problemDetails.status)) {\r\n\t\t\t\t// Non-fatal errors that the UI can handle gracefully\r\n\t\t\t\t// so we avoid showing a notification\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\t// UmbProblemDetails, show notification\r\n\t\t\tmessage = apiError.problemDetails.title;\r\n\t\t\tdetails = apiError.problemDetails.errors ?? undefined;\r\n\r\n\t\t\t// Special handling for ObjectCacheAppCache corruption errors, which we are investigating\r\n\t\t\tif (\r\n\t\t\t\tapiError.problemDetails.detail?.includes('ObjectCacheAppCache') ||\r\n\t\t\t\tapiError.problemDetails.detail?.includes('Umbraco.Cms.Infrastructure.Scoping.Scope.DisposeLastScope()')\r\n\t\t\t) {\r\n\t\t\t\theadline = 'Please restart the server';\r\n\t\t\t\tmessage =\r\n\t\t\t\t\t'The Umbraco object cache is corrupt, but your action may still have been executed. Please restart the server to reset the cache. This is a work in progress.';\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\t// Unknown error, show notification\r\n\t\t\tmessage = apiError instanceof Error ? apiError.message : 'An unknown error occurred.';\r\n\t\t}\r\n\r\n\t\tthis._peekError(headline, message, details);\r\n\t\tconsole.error('[UmbTryExecuteController] Error in request:', error);\r\n\t}\r\n}\r\n","import type { UmbApiResponse, UmbTryExecuteOptions } from '../types.js';\r\nimport { UmbTryExecuteController } from './try-execute.controller.js';\r\nimport type { UmbControllerHost } from '@umbraco-cms/backoffice/controller-api';\r\n\r\n/**\r\n * Make a request and handle errors.\r\n * @param {UmbControllerHost} host The host to use for the request and where notifications will be shown.\r\n * @param {Promise<T>} promise The promise to execute.\r\n * @param {UmbTryExecuteOptions} opts Options for the request.\r\n * @returns {Promise<UmbApiResponse<T>>} A promise that resolves with the response data or rejects with an error.\r\n * @template T The type of the response data.\r\n * @example\r\n * const { data, error } = await tryExecute(this, myPromise, {\r\n *   abortSignal: myAbortSignal,\r\n *   disableNotifications: false,\r\n * });\r\n * if (!error) {\r\n *\t console.log('Success:', data);\r\n * }\r\n */\r\nexport async function tryExecute<T>(\r\n\thost: UmbControllerHost,\r\n\tpromise: Promise<T>,\r\n\topts?: UmbTryExecuteOptions,\r\n): Promise<UmbApiResponse<T>> {\r\n\tconst controller = new UmbTryExecuteController(host, promise);\r\n\tconst response = await controller.tryExecute(opts);\r\n\tcontroller.destroy();\r\n\treturn response;\r\n}\r\n","import { tryExecute } from './tryExecute.function.js';\r\nimport type { UmbControllerHost } from '@umbraco-cms/backoffice/controller-api';\r\n\r\n/**\r\n * Batches promises and returns a promise that resolves to an array of results\r\n * @param {UmbControllerHost} host - The host to use for the request and where notifications will be shown\r\n * @param {Array<Array<BatchEntryType>>} chunks - The array of chunks to process\r\n * @param {(chunk: Array<BatchEntryType>) => Promise<PromiseResult>} callback - The function to call for each chunk\r\n * @returns {Promise<PromiseSettledResult<PromiseResult>[]>} - A promise that resolves to an array of results\r\n */\r\nexport function batchTryExecute<BatchEntryType, PromiseResult>(\r\n\thost: UmbControllerHost,\r\n\tchunks: Array<Array<BatchEntryType>>,\r\n\tcallback: (chunk: Array<BatchEntryType>) => Promise<PromiseResult>,\r\n): Promise<PromiseSettledResult<PromiseResult>[]> {\r\n\treturn Promise.allSettled(chunks.map((chunk) => tryExecute(host, callback(chunk), { disableNotifications: true })));\r\n}\r\n","import type { UmbApiResponse } from '../types.js';\r\nimport { UmbTryExecuteController } from './try-execute.controller.js';\r\nimport type { UmbControllerHost } from '@umbraco-cms/backoffice/controller-api';\r\nimport { UmbDeprecation } from '@umbraco-cms/backoffice/utils';\r\n\r\n/**\r\n * Make a request and notify the user of any errors.\r\n * This function is a wrapper around the {@link tryExecute} function and will notify the user of any errors.\r\n * It is useful for making requests where you want to handle errors in a consistent way.\r\n * @param {UmbControllerHost} host The host to use for the request.\r\n * @param {Promise<T>} resource The resource to request.\r\n * @returns {Promise<UmbApiResponse<T>>} A promise that resolves with the response data or rejects with an error.\r\n * @template T The type of the response data.\r\n * @deprecated Use the {@link tryExecute} function instead and handle the error in the caller.\r\n * This function is kept for backwards compatibility and will be removed in a future version.\r\n */\r\nexport async function tryExecuteAndNotify<T>(\r\n\thost: UmbControllerHost,\r\n\tresource: Promise<T>,\r\n): Promise<UmbApiResponse<T>> {\r\n\tnew UmbDeprecation({\r\n\t\tdeprecated: 'The tryExecuteAndNotify function is deprecated.',\r\n\t\tremoveInVersion: '18.0.0',\r\n\t\tsolution: 'Use the tryExecute function with options instead.',\r\n\t}).warn();\r\n\tconst controller = new UmbTryExecuteController(host, resource);\r\n\tconst response = await controller.tryExecute({ disableNotifications: false });\r\n\tcontroller.destroy();\r\n\treturn response;\r\n}\r\n","import { UmbCancelError } from './umb-error.js';\r\n\r\nexport interface OnCancel {\r\n\treadonly isResolved: boolean;\r\n\treadonly isRejected: boolean;\r\n\treadonly isCancelled: boolean;\r\n\r\n\t(cancelHandler: () => void): void;\r\n}\r\n\r\nexport class UmbCancelablePromise<T> implements Promise<T> {\r\n\tprivate _isResolved: boolean;\r\n\tprivate _isRejected: boolean;\r\n\tprivate _isCancelled: boolean;\r\n\treadonly cancelHandlers: (() => void)[];\r\n\treadonly promise: Promise<T>;\r\n\tprivate _resolve?: (value: T | PromiseLike<T>) => void;\r\n\tprivate _reject?: (reason?: unknown) => void;\r\n\r\n\tconstructor(\r\n\t\texecutor: (\r\n\t\t\tresolve: (value: T | PromiseLike<T>) => void,\r\n\t\t\treject: (reason?: unknown) => void,\r\n\t\t\tonCancel: OnCancel,\r\n\t\t) => void,\r\n\t) {\r\n\t\tthis._isResolved = false;\r\n\t\tthis._isRejected = false;\r\n\t\tthis._isCancelled = false;\r\n\t\tthis.cancelHandlers = [];\r\n\t\tthis.promise = new Promise<T>((resolve, reject) => {\r\n\t\t\tthis._resolve = resolve;\r\n\t\t\tthis._reject = reject;\r\n\r\n\t\t\tconst onResolve = (value: T | PromiseLike<T>): void => {\r\n\t\t\t\tif (this._isResolved || this._isRejected || this._isCancelled) {\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tthis._isResolved = true;\r\n\t\t\t\tif (this._resolve) this._resolve(value);\r\n\t\t\t};\r\n\r\n\t\t\tconst onReject = (reason?: unknown): void => {\r\n\t\t\t\tif (this._isResolved || this._isRejected || this._isCancelled) {\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tthis._isRejected = true;\r\n\t\t\t\tif (this._reject) this._reject(reason);\r\n\t\t\t};\r\n\r\n\t\t\tconst onCancel = (cancelHandler: () => void): void => {\r\n\t\t\t\tif (this._isResolved || this._isRejected || this._isCancelled) {\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tthis.cancelHandlers.push(cancelHandler);\r\n\t\t\t};\r\n\r\n\t\t\tObject.defineProperty(onCancel, 'isResolved', {\r\n\t\t\t\tget: (): boolean => this._isResolved,\r\n\t\t\t});\r\n\r\n\t\t\tObject.defineProperty(onCancel, 'isRejected', {\r\n\t\t\t\tget: (): boolean => this._isRejected,\r\n\t\t\t});\r\n\r\n\t\t\tObject.defineProperty(onCancel, 'isCancelled', {\r\n\t\t\t\tget: (): boolean => this._isCancelled,\r\n\t\t\t});\r\n\r\n\t\t\treturn executor(onResolve, onReject, onCancel as OnCancel);\r\n\t\t});\r\n\t}\r\n\r\n\tget [Symbol.toStringTag]() {\r\n\t\treturn 'Cancellable Promise';\r\n\t}\r\n\r\n\tpublic then<TResult1 = T, TResult2 = never>(\r\n\t\tonFulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | null,\r\n\t\tonRejected?: ((reason: unknown) => TResult2 | PromiseLike<TResult2>) | null,\r\n\t): Promise<TResult1 | TResult2> {\r\n\t\treturn this.promise.then(onFulfilled, onRejected);\r\n\t}\r\n\r\n\tpublic catch<TResult = never>(\r\n\t\tonRejected?: ((reason: unknown) => TResult | PromiseLike<TResult>) | null,\r\n\t): Promise<T | TResult> {\r\n\t\treturn this.promise.catch(onRejected);\r\n\t}\r\n\r\n\tpublic finally(onFinally?: (() => void) | null): Promise<T> {\r\n\t\treturn this.promise.finally(onFinally);\r\n\t}\r\n\r\n\tpublic cancel(): void {\r\n\t\tif (this._isResolved || this._isRejected || this._isCancelled) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tthis._isCancelled = true;\r\n\t\tif (this.cancelHandlers.length) {\r\n\t\t\ttry {\r\n\t\t\t\tfor (const cancelHandler of this.cancelHandlers) {\r\n\t\t\t\t\tcancelHandler();\r\n\t\t\t\t}\r\n\t\t\t} catch (error) {\r\n\t\t\t\tconsole.warn('Cancellation threw an error', error);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\t\tthis.cancelHandlers.length = 0;\r\n\t\tif (this._reject) this._reject(new UmbCancelError('Request aborted'));\r\n\t}\r\n\r\n\tpublic get isCancelled(): boolean {\r\n\t\treturn this._isCancelled;\r\n\t}\r\n}\r\n","import { UmbCancelablePromise } from '../cancelable-promise.js';\r\nimport { UmbApiError } from '../umb-error.js';\r\nimport { isProblemDetailsLike } from '../apiTypeValidators.function.js';\r\nimport type { UmbApiResponse, XhrRequestOptions } from '../types.js';\r\nimport { UmbTryExecuteController } from './try-execute.controller.js';\r\nimport type { UmbControllerHost } from '@umbraco-cms/backoffice/controller-api';\r\nimport { umbHttpClient } from '@umbraco-cms/backoffice/http-client';\r\n\r\n/**\r\n * Make an XHR request.\r\n * This function is a wrapper around XMLHttpRequest to provide a consistent API for making requests.\r\n * It supports cancelable promises, progress events, and custom headers.\r\n * @param {UmbControllerHost} host The host to use for the request.\r\n * @param {XhrRequestOptions} options The options for the request.\r\n * @returns {Promise<UmbApiResponse<T>>} A promise that resolves with the response data or rejects with an error.\r\n * @template T The type of the response data.\r\n */\r\nexport async function tryXhrRequest<T>(\r\n\thost: UmbControllerHost,\r\n\toptions: XhrRequestOptions,\r\n): Promise<UmbApiResponse<T>> {\r\n\tconst config = umbHttpClient.getConfig();\r\n\tconst promise = createXhrRequest<T>({\r\n\t\t...options,\r\n\t\tbaseUrl: config.baseUrl,\r\n\t\ttoken: () => (typeof config.auth === 'function' ? config.auth({ type: 'http', scheme: 'bearer' }) : config.auth),\r\n\t});\r\n\tconst controller = new UmbTryExecuteController(host, promise);\r\n\tconst response = await controller.tryExecute(options);\r\n\tcontroller.destroy();\r\n\treturn response;\r\n}\r\n\r\n/**\r\n * Create an XHR request.\r\n * @param {XhrRequestOptions} options The options for the request.\r\n * @returns {UmbCancelablePromise<T>} A cancelable promise that resolves with the response data or rejects with an error.\r\n * @template T The type of the response data.\r\n * @internal\r\n */\r\nfunction createXhrRequest<T>(options: XhrRequestOptions): UmbCancelablePromise<T> {\r\n\tconst baseUrl = options.baseUrl || '/umbraco';\r\n\r\n\treturn new UmbCancelablePromise<T>(async (resolve, reject, onCancel) => {\r\n\t\tconst xhr = new XMLHttpRequest();\r\n\t\txhr.open(options.method, `${baseUrl}${options.url}`, true);\r\n\r\n\t\t// Set default headers\r\n\t\tif (options.token) {\r\n\t\t\tconst token = typeof options.token === 'function' ? await options.token() : options.token;\r\n\t\t\tif (token) {\r\n\t\t\t\txhr.setRequestHeader('Authorization', `Bearer ${token}`);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Infer Content-Type header based on body type\r\n\t\tif (options.body instanceof FormData) {\r\n\t\t\t// Note: 'multipart/form-data' is automatically set by the browser for FormData\r\n\t\t} else {\r\n\t\t\txhr.setRequestHeader('Content-Type', 'application/json');\r\n\t\t}\r\n\r\n\t\t// Set custom headers\r\n\t\tif (options.headers) {\r\n\t\t\tfor (const [key, value] of Object.entries(options.headers)) {\r\n\t\t\t\txhr.setRequestHeader(key, value);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\txhr.upload.onprogress = (event) => {\r\n\t\t\tif (options.onProgress) {\r\n\t\t\t\toptions.onProgress(event);\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\txhr.onload = () => {\r\n\t\t\ttry {\r\n\t\t\t\tif (xhr.status >= 200 && xhr.status < 300) {\r\n\t\t\t\t\tif (options.responseHeader) {\r\n\t\t\t\t\t\tconst response = xhr.getResponseHeader(options.responseHeader);\r\n\t\t\t\t\t\tresolve(response as T);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tresolve(JSON.parse(xhr.responseText));\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\treject(createErrorResponse(xhr));\r\n\t\t\t\t}\r\n\t\t\t} catch {\r\n\t\t\t\t// This most likely happens when the response is not JSON\r\n\t\t\t\treject(\r\n\t\t\t\t\tnew UmbApiError(`Failed to make request: ${xhr.statusText}`, xhr.status, xhr, {\r\n\t\t\t\t\t\ttitle: xhr.statusText,\r\n\t\t\t\t\t\ttype: 'ApiError',\r\n\t\t\t\t\t\tstatus: xhr.status,\r\n\t\t\t\t\t}),\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\txhr.onerror = () => {\r\n\t\t\treject(createErrorResponse(xhr));\r\n\t\t};\r\n\r\n\t\tif (!onCancel.isCancelled) {\r\n\t\t\t// Handle body based on Content-Type\r\n\t\t\tif (options.body instanceof FormData) {\r\n\t\t\t\txhr.send(options.body);\r\n\t\t\t} else {\r\n\t\t\t\txhr.send(JSON.stringify(options.body));\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tonCancel(() => {\r\n\t\t\txhr.abort();\r\n\t\t});\r\n\t});\r\n}\r\n\r\n/**\r\n * Create an error response from an XMLHttpRequest.\r\n * This function is used to create a consistent error response format for failed requests.\r\n * It extracts the status, statusText, and responseText from the XMLHttpRequest object and creates an UmbApiError object.\r\n * It tries to parse the responseText as JSON and, if successful, adds it to the UmbApiError object as UmbProblemDetails.\r\n * @param {XMLHttpRequest} xhr The XMLHttpRequest object\r\n * @returns {UmbApiError} An UmbApiError object containing the error details.\r\n * @internal\r\n */\r\nfunction createErrorResponse(xhr: XMLHttpRequest): UmbApiError {\r\n\tconst error = new UmbApiError(xhr.statusText, xhr.status, xhr, {\r\n\t\ttitle: xhr.statusText,\r\n\t\ttype: 'ApiError',\r\n\t\tstatus: xhr.status,\r\n\t});\r\n\ttry {\r\n\t\tconst errorBody = xhr.responseText;\r\n\t\tif (errorBody) {\r\n\t\t\tconst parsedError = JSON.parse(errorBody);\r\n\t\t\tif (parsedError && isProblemDetailsLike(parsedError)) {\r\n\t\t\t\terror.problemDetails = parsedError;\r\n\t\t\t}\r\n\t\t}\r\n\t} catch {\r\n\t\t// Ignore JSON parsing errors\r\n\t}\r\n\r\n\treturn error;\r\n}\r\n"],"names":["extractUmbNotificationColor","type","EventMessageTypeModel","objectIsUmbNotification","notification","object","isUmbNotifications","notifications","UMB_NOTIFICATION_HEADER","isApiError","error","isCancelError","isCancelablePromise","promise","isProblemDetailsLike","MAX_RETRIES","UmbApiInterceptorController","UmbControllerBase","#pending401Requests","#nonGet401Requests","client","response","request","requestConfig","problemDetails","newResponse","#createResponse","authContext","UMB_AUTH_CONTEXT","retries","existing","req","resolve","reject","data","retryResponse","generatedResource","notFoundProblemDetails","errorBody","e","umbNotifications","#peekError","context","errors","body","originalResponse","isString","contentType","responseBody","headersOverride","value","key","headline","message","details","color","host","UmbError","UmbCancelError","UmbApiError","status","UmbResourceController","alias","IGNORED_ERROR_CODES","UmbTryExecuteController","#abortSignal","opts","umbError","#notifyOnError","apiError","tryExecute","controller","batchTryExecute","chunks","callback","chunk","tryExecuteAndNotify","resource","UmbDeprecation","UmbCancelablePromise","executor","onResolve","onReject","reason","onCancel","cancelHandler","onFulfilled","onRejected","onFinally","tryXhrRequest","options","config","umbHttpClient","createXhrRequest","baseUrl","xhr","token","event","createErrorResponse","parsedError"],"mappings":"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"}